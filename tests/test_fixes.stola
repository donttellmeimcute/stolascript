// ==========================================================
// test_fixes.stola — verifica los tres cambios recientes
//
//  1. ISR rsi/rdi: la ISR vacía se inspecciona en el .s
//  2. ws_select:   poll con timeout sobre servidor sin clientes
//                  → debe devolver [] (0 fds) en ~timeout ms
//  3. SIGSEGV:     el runtime lo instala; ejecucion normal OK
// ==========================================================

// ── Prueba 1: ISR ─────────────────────────────────────────
// Declarar la ISR; la verificacion real es en el .s generado.
// En el epilogo debe aparecer:  pop rdi / pop rsi
interrupt function dummy_isr()
end

// ── Prueba 2: ws_select timeout ───────────────────────────
// Crear servidor, NO conectar ningun cliente, llamar ws_select
// con timeout=80 ms.  Como nadie se conecta, el resultado
// debe ser un array vacio (0 fds listos).
// Esto verifica que ws_select: compila, ejecuta, respeta el
// timeout y devuelve el array correcto.

function run_ws_select_test()
  port = 9292
  server = ws_server_create(port)

  handles = [server]
  ready = ws_select(handles, 80)
  count = length(ready)

  ws_server_close(server)
  return count
end

result = run_ws_select_test()
print("ws_select timeout test — fds listos: " plus to_string(result))

if result equals 0
  print("PASS: ws_select devolvio 0 fds (timeout sin clientes, correcto)")
else
  print("FAIL: se esperaba 0, se obtuvo " plus to_string(result))
end

// ── Prueba 3: SIGSEGV handler ─────────────────────────────
// El handler (sigaction + SA_SIGINFO) se instalo en
// stola_setup_runtime.  Una ejecucion normal completa sin crash.
print("SIGSEGV handler instalado — ejecucion normal: OK")

